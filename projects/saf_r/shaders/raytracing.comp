#version 450 core
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Material {
    vec3 albedo;
    vec3 diffuse_color;
    float specular_exponent;
};

struct Light{
    vec3 position;
    float intensity;
};

struct Sphere{
    vec3 center;
    float radius;
    Material material;
};

layout(std430, binding = 0) coherent buffer lights{
    Light inLights[];
};

layout(std430, binding = 1) coherent buffer materials{
    Material inMaterials[];
};

layout(std430, binding = 2) coherent buffer spheres{
    Sphere inSpheres[];
};

layout(set=0, binding=3, rgba8) uniform image2D outImage;



vec3 safr_reflect(const vec3 dir, const vec3 hit_center) {
    return dir - hit_center * 2.f * (dot(dir, hit_center));
}

bool ray_intersect(const vec3 origin, const vec3 dir, float t0, int id){
        vec3 L = inSpheres[id].center - origin;
        float tca = dot(L, dir);
        float d2 = dot(L, L) - tca * tca;
        if (d2 > inSpheres[id].radius * inSpheres[id].radius){
            return false;
        }
        float thc = float(sqrt(inSpheres[id].radius * inSpheres[id].radius - d2));
        t0 = tca - thc;
        float t1 = tca + thc;
        if (t0 < 0) {
            t0 = t1;
        }
        if (t0 < 0){
            return false;
        }
        return true;
}

int sceneIntersect(const vec3 orig, const vec3 dir, vec3 hit, vec3 hit_center, Material material) {
    float spheres_dist = 1.0 / 0.0;
    int index = -1;
    for (int i = 0; i < inSpheres.length(); i++) {
        float dist_i;
        if (ray_intersect(orig, dir, dist_i, i) && dist_i < spheres_dist) {
            spheres_dist = dist_i;
            hit = orig + dir * dist_i;
            hit_center = normalize(hit - inSpheres[i].center);
            material = inSpheres[i].material;
            index = i;
            break;
        }
    }
    if(spheres_dist < 1000){
        return index;
    }
    return -1;
}


vec3 castRay(const vec3 orig, const vec3 dir, int max_depth) {

    // max depth is 5
    int depth = 0;
    vec3 point, hit_center;
    Material material;
    vec3 result = vec3(0.2, 0.7, 0.8);
    int intersect;
    vec3 direction = dir;
    vec3 reflect_dir = direction;
    vec3 reflect_orig = orig;

    for(int i = 0; i < depth;i++){
        depth++;
        intersect = sceneIntersect(reflect_orig, reflect_dir, point, hit_center, material);
        if(intersect != -1){
            break;
        }
        //compute recursive directions and origins of rays and then call the function
        reflect_dir = normalize(safr_reflect(direction, hit_center));
        reflect_orig = (dot(reflect_dir, hit_center) < 0) ? point - hit_center * float(1e-3) : point + hit_center * float(1e-3);// offset the original point to avoid occlusion by the object itself
        direction = reflect_dir;
    }

    if(intersect != -1){
        vec3 reflect_color = result;
        for(int i = 0; i < depth; i++){

            //compute shadows and other light properties for the returned ray color
            float diffuse_light_intensity = 0, specular_light_intensity = 0;

            for (int i = 0; i < inLights.length(); i++) {
                vec3 light_dir = normalize(inLights[i].position - point);
                float light_distance = distance(inLights[i].position, point);

                vec3 shadow_orig = (dot(light_dir, hit_center) < 0) ? point - hit_center * float(1e-3) :
                point + hit_center * float(1e-3);// checking if the point lies in the shadow of the lights[i]
                vec3 shadow_pt, shadow_hit_center;
                Material tmpmaterial;
                if ((sceneIntersect(shadow_orig, light_dir, shadow_pt, shadow_hit_center, tmpmaterial) != -1)
                && distance(shadow_pt, shadow_orig) < light_distance){
                    continue;
                }
                diffuse_light_intensity += inLights[i].intensity * max(0.f, dot(light_dir, hit_center));
                specular_light_intensity += pow(max(0.f, dot(safr_reflect(light_dir, hit_center), dir)), material.specular_exponent) * inLights[i].intensity;
            }
            result = material.diffuse_color * diffuse_light_intensity * material.albedo[0] +
            vec3(1., 1., 1.) * specular_light_intensity * material.albedo[1] + reflect_color * material.albedo[2];
        }
    }
    return result;
}

vec3 computeDirection(ivec2 coord){

    //float x = (2 * (i + 0.5f) / (float)width - 1) * tan(fov / 2.f) * width / (float)height;
    //float y = -(2 * (j + 0.5f) / (float)height - 1) * tan(fov / 2.f);
    //glm::vec3 dir = glm::normalize(glm::vec3(x, y, -1));

    return vec3(1,1,1);
}


void main(){
    //ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
   // int max_depth = 4;
    //vec3 direction = computeDirection(coord);
    //vec3 color = castRay(vec3(0,0,0), direction, max_depth);
   // vec3 color = vec3(1,0,0);
    //imageStore(outImage, coord, vec4(color, 0));
}