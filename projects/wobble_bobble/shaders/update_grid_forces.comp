#version 450
#extension GL_GOOGLE_include_directive : enable

const float PI = 3.1415926535897932384626433832795;

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

#include "particle.inc"

layout(set=0, binding=0, rgba32f) restrict readonly uniform image3D gridImage;
layout(set=0, binding=1, rgba32f) restrict writeonly uniform image3D gridForceImage;
layout(set=0, binding=2, std430) buffer particleBuffer {
    Particle particles [];
};

layout( push_constant ) uniform constants {
    float K;
    float E;
    float t;
    float dt;
};

#define SHARED_PARTICLES_BATCH_SIZE 64

shared Particle shared_particles [SHARED_PARTICLES_BATCH_SIZE];

void main()	{
    const float K9_E = (9.0f * K - E);

    float lame1 = 3.0f * K * (3.0f * K - E);
    float lame2 = 3.0f * K * E;
    float poisson = (3.0f * K - E);
    float M = 3.0f * K * (3.0f * K + E);

    if (K9_E > 0.0f) {
        lame1 /= K9_E;
        lame2 /= K9_E;
        M /= K9_E;
    }

    if (K > 0.0f) {
        poisson /= (6.0f * K);
    }

    const vec3 position = (vec3(gl_GlobalInvocationID) + vec3(0.5f)) / imageSize(gridImage);

    memoryBarrierImage();

    vec4 gridSample = imageLoad(
        gridImage,
        ivec3(gl_GlobalInvocationID)
    );

    vec3 velocity = gridSample.xyz;
    float mass = gridSample.w;

    vec3 force = vec3(0.0f);
    uint offset = 0;

    memoryBarrierBuffer();

    for (offset = 0; offset < particles.length(); offset += SHARED_PARTICLES_BATCH_SIZE) {
        uint localOffset = offset + gl_LocalInvocationIndex;

        if (localOffset < particles.length()) {
            shared_particles[gl_LocalInvocationIndex] = particles[localOffset];
        } else {
            shared_particles[gl_LocalInvocationIndex].minimal.position = vec3(0.0f);
            shared_particles[gl_LocalInvocationIndex].minimal.size = 0.0f;
            shared_particles[gl_LocalInvocationIndex].minimal.velocity = vec3(0.0f);
            shared_particles[gl_LocalInvocationIndex].minimal.mass = 0.0f;
            shared_particles[gl_LocalInvocationIndex].deformation = mat4(0.0f);
        }

        memoryBarrierShared();

        for (uint i = 0; i < SHARED_PARTICLES_BATCH_SIZE; i++) {
            float size = shared_particles[gl_LocalInvocationIndex].minimal.size;
            float volume = 4.0f / 3.0f * PI * size * size * size;
            mat3 F = mat3(shared_particles[gl_LocalInvocationIndex].deformation);

            float J = determinant(F);

            if ((J > 0.0f) && (volume > 0.0f)) {
                mat3 F_invT = inverse(transpose(F));

                vec3 v = shared_particles[gl_LocalInvocationIndex].minimal.velocity;
                float m = shared_particles[gl_LocalInvocationIndex].minimal.mass;

                mat3 delta = lame2 * (F - F_invT) + lame1 * log(J) * F_invT;

                vec3 weight_gradient = voxel_particle_grad_weight(
                    position,
                    shared_particles[gl_LocalInvocationIndex].minimal
                );

                force -= (
                    volume *
                    delta * transpose(F) *
                    weight_gradient
                );
            }
        }
    }

    if (dt > 0.0f) {
        if (mass > 0.0f) {
            velocity += force * dt / mass;
        }
    }

    bvec3 lowerID = lessThanEqual(gl_GlobalInvocationID, ivec3(0));
    bvec3 negativeVelocity = lessThan(velocity, vec3(0.0f));

    bvec3 greaterID = greaterThanEqual(gl_GlobalInvocationID + ivec3(1), imageSize(gridImage));
    bvec3 positiveVelocity = greaterThan(velocity, vec3(0.0f));

    bvec3 invert = bvec3(
        (lowerID.x && negativeVelocity.x) || (greaterID.x && positiveVelocity.x),
        (lowerID.y && negativeVelocity.y) || (greaterID.y && positiveVelocity.y),
        (lowerID.z && negativeVelocity.z) || (greaterID.z && positiveVelocity.z)
    );

    velocity = mix(velocity, -velocity, invert);

    imageStore(
        gridForceImage,
        ivec3(gl_GlobalInvocationID),
        vec4(velocity, mass)
    );

    memoryBarrierImage();
}