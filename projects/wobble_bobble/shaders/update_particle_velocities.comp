#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "particle.inc"

layout(set=0, binding=0, std430) restrict buffer particleBuffer {
    Particle particles [];
};

layout(set=0, binding=1) uniform texture3D gridImage;
layout(set=0, binding=2) uniform texture3D gridOldImage;
layout(set=0, binding=3) uniform sampler gridSampler;

layout( push_constant ) uniform constants {
    float alpha;
    float beta;
};

void main()	{
    memoryBarrierBuffer();
    memoryBarrierImage();

    if (gl_GlobalInvocationID.x < particles.length()) {
        ParticleMinimal minimal = particles[gl_GlobalInvocationID.x].minimal;

        ivec3 gridResolution = textureSize(sampler3D(gridImage, gridSampler), 0);
        ivec3 gridWindow = ivec3(minimal.size * 2.0f * gridResolution);

        mat3 affine_D = mat3(0.0f);
        mat3 affine_B = mat3(0.0f);

        vec3 velocity_pic = vec3(0.0f);
        vec3 velocity_flip = vec3(minimal.velocity);

        int i, j, k;

        for (i = -gridWindow.x; i <= gridWindow.x; i++) {
            for (j = -gridWindow.y; j <= gridWindow.y; j++) {
                for (k = -gridWindow.z; k <= gridWindow.z; k++) {
                    vec3 offset = vec3(i, j, k) / gridResolution;
                    vec3 voxel = minimal.position + offset;

                    vec4 gridSample = texture(sampler3D(gridImage, gridSampler), voxel);
                    vec4 gridOldSample = texture(sampler3D(gridOldImage, gridSampler), voxel);

                    float weight = voxel_particle_weight(voxel, minimal);
                    vec3 velocity = gridSample.xyz * weight;

                    affine_D += outerProduct(weight * offset, offset);
                    affine_B += outerProduct(velocity, offset);

                    velocity_pic += velocity;
                    velocity_flip += (gridSample.xyz - gridOldSample.xyz) * weight;
                }
            }
        }

        barrier();
        memoryBarrierBuffer();

        mat3 affine_C = mat3(0.0f);
        vec3 velocity_apic = vec3(0.0f);

        if (abs(determinant(affine_D)) > 0.0f) {
            affine_C = affine_B * inverse(affine_D);
        }

        for (i = -gridWindow.x; i <= gridWindow.x; i++) {
            for (j = -gridWindow.y; j <= gridWindow.y; j++) {
                for (k = -gridWindow.z; k <= gridWindow.z; k++) {
                    vec3 offset = vec3(i, j, k) / gridResolution;

                    velocity_apic += affine_C * offset;
                }
            }
        }

        barrier();
        memoryBarrierBuffer();

        vec3 velocity_alpha = mix(velocity_pic, velocity_flip, alpha);
        vec3 velocity_beta = mix(velocity_alpha, velocity_apic, beta);

        particles[gl_GlobalInvocationID.x].minimal.velocity = velocity_beta;
    }

    barrier();
    memoryBarrierBuffer();
}