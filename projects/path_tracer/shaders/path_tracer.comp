#version 450 core
#extension GL_ARB_separate_shader_objects : enable

const float pi      = 3.1415926535897932384626433832795;
const float hitBias = 0.0001;   // used to offset hits to avoid self intersection

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Material {
    vec3 	emission;
	float 	padding0;
    vec3 	albedo;
    float 	padding1;
};

struct Sphere{
    vec3 	center;
    float 	radius;
    int 	materialIndex;
	float 	padding[3];
};

struct Plane{
	vec3 	center;
	int 	materialIndex;
	vec3 	N;
	float 	padding1;
	vec2 	extent;
	vec2 	padding2;
};

layout(std430, binding = 0) buffer spheres{
    Sphere inSpheres[];
};

layout(std430, binding = 1) buffer planes{
    Plane inPlanes[];
};

layout(std430, binding = 2) buffer materials{
    Material inMaterials[];
};

layout(set=0, binding = 3, rgba32f) uniform image2D outImage;

layout( push_constant ) uniform constants{
    mat4 	viewToWorld;
    int 	sphereCount;
	int 	planeCount;
	int 	frameIndex;
};

// ---- Intersection functions ----

struct Ray{
	vec3 origin;
	vec3 direction;
};

struct Intersection{
    bool 		hit;
	float 		distance;
    vec3 		pos;
    vec3 		N;
    Material 	material;
};

Intersection raySphereIntersect(Ray ray, Sphere sphere){

	Intersection intersection;
	intersection.hit = false;
	
    vec3 	L 	= sphere.center - ray.origin;
    float 	tca = dot(L, ray.direction);
    float 	d2 	= dot(L, L) - tca * tca;
    if (d2 > sphere.radius * sphere.radius){
        return intersection;
    }
    float thc = float(sqrt(sphere.radius * sphere.radius - d2));
    float t0 = tca - thc;
    float t1 = tca + thc;
    if (t0 < 0) {
        t0 = t1;
    }
    if (t0 < 0){
        return intersection;
    }
	
	intersection.hit 		= true;
	intersection.distance 	= t0;
	intersection.pos        = ray.origin + ray.direction * intersection.distance;
	intersection.N          = normalize(intersection.pos - sphere.center);
	intersection.material 	= inMaterials[sphere.materialIndex];
	
    return intersection;
}

struct Basis{
	vec3 right;
	vec3 up;
	vec3 forward;
};

Basis buildBasisAroundNormal(vec3 N){
	Basis 	basis;
	basis.up 		= N;
	basis.right 	= abs(basis.up.x) < 0.99 ?  vec3(1, 0, 0) : vec3(0, 0, 1);
	basis.forward 	= normalize(cross(basis.up, basis.right));
	basis.right 	= cross(basis.up, basis.forward);
	return basis;
}

// see: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection
Intersection rayPlaneIntersect(Ray ray, Plane plane){

	Intersection intersection;
	intersection.hit = false;

	vec3 	toPlane = plane.center - ray.origin;
	float 	denom 	= dot(ray.direction, plane.N);
	if(abs(denom) < 0.001)
		return intersection;
		
	intersection.distance = dot(toPlane, plane.N) / denom;
	
	if(intersection.distance < 0)
		return intersection;
	
	intersection.pos 				= ray.origin + ray.direction * intersection.distance;
	
	vec3 	centerToIntersection	= intersection.pos - plane.center;
	Basis 	planeBasis 				= buildBasisAroundNormal(plane.N);
	float 	projectedRight			= dot(centerToIntersection, planeBasis.right);
	float 	projectedUp				= dot(centerToIntersection, planeBasis.forward);

	intersection.hit 		= abs(projectedRight) <= plane.extent.x && abs(projectedUp) <= plane.extent.y;
	intersection.N 			= plane.N;
	intersection.material 	= inMaterials[plane.materialIndex];
	
	return intersection;
}

Intersection sceneIntersect(Ray ray) {
    float minDistance = 100000;  // lets start with something big
    
    Intersection intersection;
    intersection.hit = false;
    
    for (int i = 0; i < sphereCount; i++) {
		Intersection sphereIntersection = raySphereIntersect(ray, inSpheres[i]);
        if (sphereIntersection.hit && sphereIntersection.distance < minDistance) {            
            intersection 	= sphereIntersection;
			minDistance 	= intersection.distance;
        }
    }
	for (int i = 0; i < planeCount; i++){
		Intersection planeIntersection = rayPlaneIntersect(ray, inPlanes[i]);
        if (planeIntersection.hit && planeIntersection.distance < minDistance) {
            intersection 	= planeIntersection;
			minDistance 	= intersection.distance;
        }
	}
    return intersection;
}

vec3 biasHitPosition(vec3 hitPos, vec3 rayDirection, vec3 N){
    // return hitPos + N * hitBias; // works as long as no refraction/transmission is used and camera is outside sphere
    return hitPos + sign(dot(rayDirection, N)) * N * hitBias;
}

// ---- noise/hash functions for pseudorandom variables ----

// extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences
vec2 r2Sequence(uint n){
	n = n % 42000;
	const float g = 1.32471795724474602596;
	return fract(vec2(
		n /  g,
		n / (g*g)));
}

// random() and helpers from: https://www.shadertoy.com/view/XlycWh
float g_seed = 0;

uint base_hash(uvec2 p) {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
}

vec2 hash2(inout float seed) {
    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));
    uvec2 rz = uvec2(n, n*48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);
}

void initRandom(ivec2 coord){
	g_seed = float(base_hash(coord)/float(0xffffffffU)+frameIndex);
}

vec2 random(){
	return hash2(g_seed);
}

// ---- shading ----

vec3 lambertBRDF(vec3 albedo){
	return albedo / pi;
}

vec3 computeBRDF(Material material){
    return lambertBRDF(material.albedo);
}

// ---- pathtracing and main ----

float cosineDistributionPDF(float NoL){
	return NoL / pi;
}

// https://link.springer.com/content/pdf/10.1007/978-1-4842-4427-2_16.pdf
vec3 cosineDistribution(vec2 xi){
	float phi = 2 * pi * xi.y;
	return vec3(
		sqrt(xi.x) * cos(phi),
		sqrt(1 - xi.x),
		sqrt(xi.x) * sin(phi));
}

vec3 sampleTangentToWorldSpace(vec3 tangentSpaceSample, vec3 N){
	Basis tangentBasis = buildBasisAroundNormal(N);
	return
		tangentBasis.right		* tangentSpaceSample.x +
		tangentBasis.up			* tangentSpaceSample.y +
		tangentBasis.forward 	* tangentSpaceSample.z;
}

vec3 castRay(Ray ray) {
    
    vec3 skyColor 	= vec3(0.2, 0.7, 0.8);
	skyColor 		= vec3(0);
    
    vec3   	throughput 	= vec3(1);
    vec3	color   	= vec3(0);
    
	const int maxDepth = 10;
    for(int i = 0; i < maxDepth; i++){

        Intersection intersection = sceneIntersect(ray);
        
        vec3 hitLighting 	= vec3(0);
        vec3 brdf 			= vec3(1);
		
		vec3 L 				= -normalize(ray.direction);
        float NoL 			= max(dot(L, intersection.N), 0);
		
        if(intersection.hit){
            brdf 		= computeBRDF(intersection.material);
			hitLighting = intersection.material.emission * max(sign(NoL), 0);	// objects only emit in direction of normal
        }
        else{
            hitLighting = skyColor;
        }
        
        color       	+= hitLighting * throughput;
        throughput  	*= brdf * NoL / max(cosineDistributionPDF(NoL), 0.0001);
        
        if(!intersection.hit)
            break;

		vec3 sampleTangentSpace = cosineDistribution(random());
        ray.direction   		= sampleTangentToWorldSpace(sampleTangentSpace, intersection.N);
        ray.origin				= biasHitPosition(intersection.pos, ray.direction, intersection.N);
    }

    return color;
}

// coord must be in pixel coordinates, but already shifted to pixel center
vec3 computeCameraRay(vec2 coord){

    ivec2 outImageRes   = imageSize(outImage);
    float fovDegree     = 45;
    float fov           = fovDegree * pi / 180;
    
    vec2 uv     		= coord / vec2(outImageRes);
    vec2 ndc    		= 2 * uv - 1;
    
    float tanFovHalf    = tan(fov / 2.f);
    float aspectRatio   = outImageRes.x / float(outImageRes.y);
    float x             =  ndc.x * tanFovHalf * aspectRatio;
    float y             = -ndc.y * tanFovHalf;
    
    // view direction goes through pixel on image plane with z=1
    vec3 directionViewSpace     = normalize(vec3(x, y, 1));
    vec3 directionWorldSpace    = mat3(viewToWorld) * directionViewSpace;
    return directionWorldSpace;
}

void main(){
    ivec2 	coord     = ivec2(gl_GlobalInvocationID.xy);
	vec2 	pixelSize = 1.f / coord;
	initRandom(coord);
	
	Ray cameraRay;
    cameraRay.origin  	= viewToWorld[3].xyz;
	vec2 coordCentered 	= coord + 0.5;
	
	vec3 color = vec3(0);
	
	const int samplesPerPixel = 1;
	for(int i = 0; i < samplesPerPixel; i++){
		vec2 jitter 		= r2Sequence(i + frameIndex) - 0.5;
		cameraRay.direction = computeCameraRay(coordCentered + jitter);
		color 				+= castRay(cameraRay);
	}
	color /= samplesPerPixel;
		
	//color = vec3(random().r, random().r, random().r);
	
    imageStore(outImage, coord, vec4(color, 1.f));
}