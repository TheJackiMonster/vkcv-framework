#version 450 core
#extension GL_ARB_separate_shader_objects : enable

const float pi      = 3.1415926535897932384626433832795;
const float hitBias = 0.0001;   // used to offset hits to avoid self intersection

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

struct Material {
    vec3 	albedo;
	float 	padding;
    vec3 	diffuse_color;
    float 	specular_exponent;
};

struct Light{
    vec3 	position;
    float 	intensity;
};

struct Sphere{
    vec3 	center;
    float 	radius;
    int 	materialIndex;
	float 	padding[3];
};

struct Plane{
	vec3 	center;
	int 	materialIndex;
	vec3 	N;
	float 	padding1;
	vec2 	extent;
	vec2 	padding2;
};

layout(std430, binding = 0) buffer lights{
    Light inLights[];
};

layout(std430, binding = 1) buffer spheres{
    Sphere inSpheres[];
};

layout(std430, binding = 2) buffer planes{
    Plane inPlanes[];
};

layout(std430, binding = 3) buffer materials{
    Material inMaterials[];
};

layout(set=0, binding = 4, rgba8) uniform image2D outImage;

layout( push_constant ) uniform constants{
    mat4 	viewToWorld;
    int 	lightCount;
    int 	sphereCount;
	int 	planeCount;
};

struct Ray{
	vec3 origin;
	vec3 direction;
};

struct Intersection{
    bool 		hit;
	float 		distance;
    vec3 		pos;
    vec3 		N;
    Material 	material;
};

Intersection raySphereIntersect(Ray ray, Sphere sphere){

	Intersection intersection;
	intersection.hit = false;
	
    vec3 	L 	= sphere.center - ray.origin;
    float 	tca = dot(L, ray.direction);
    float 	d2 	= dot(L, L) - tca * tca;
    if (d2 > sphere.radius * sphere.radius){
        return intersection;
    }
    float thc = float(sqrt(sphere.radius * sphere.radius - d2));
    float t0 = tca - thc;
    float t1 = tca + thc;
    if (t0 < 0) {
        t0 = t1;
    }
    if (t0 < 0){
        return intersection;
    }
	
	intersection.hit 		= true;
	intersection.distance 	= t0;
	intersection.pos        = ray.origin + ray.direction * intersection.distance;
	intersection.N          = normalize(intersection.pos - sphere.center);
	intersection.material 	= inMaterials[sphere.materialIndex];
	
    return intersection;
}

// see: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection
Intersection rayPlaneIntersect(Ray ray, Plane plane){

	Intersection intersection;
	intersection.hit = false;

	vec3 	toPlane = plane.center - ray.origin;
	float 	denom 	= dot(ray.direction, plane.N);
	if(abs(denom) < 0.001)
		return intersection;
		
	intersection.distance = dot(toPlane, plane.N) / denom;
	
	if(intersection.distance < 0)
		return intersection;
	
	intersection.pos 				= ray.origin + ray.direction * intersection.distance;
	vec3 	right 					= abs(plane.N.x) < 0.99 ?  vec3(1, 0, 0) : vec3(0, 0, 1);
	vec3 	up 						= normalize(cross(plane.N, right));
	right 							= cross(plane.N, up);
	vec3 	centerToIntersection	= intersection.pos - plane.center;
	float 	projectedRight			= dot(centerToIntersection, right);
	float 	projectedUp				= dot(centerToIntersection, up);

	intersection.hit 		= abs(projectedRight) <= plane.extent.x && abs(projectedUp) <= plane.extent.y;
	intersection.N 			= plane.N;
	intersection.material 	= inMaterials[plane.materialIndex];
	
	return intersection;
}

Intersection sceneIntersect(Ray ray) {
    float minDistance = 100000;  // lets start with something big
    
    Intersection intersection;
    intersection.hit = false;
    
    for (int i = 0; i < sphereCount; i++) {
		Intersection sphereIntersection = raySphereIntersect(ray, inSpheres[i]);
        if (sphereIntersection.hit && sphereIntersection.distance < minDistance) {            
            intersection 	= sphereIntersection;
			minDistance 	= intersection.distance;
        }
    }
	for (int i = 0; i < planeCount; i++){
		Intersection planeIntersection = rayPlaneIntersect(ray, inPlanes[i]);
        if (planeIntersection.hit && planeIntersection.distance < minDistance) {
            intersection 	= planeIntersection;
			minDistance 	= intersection.distance;
        }
	}
    return intersection;
}

vec3 biasHitPosition(vec3 hitPos, vec3 rayDirection, vec3 N){
    // return hitPos + N * hitBias; // works as long as no refraction/transmission is used and camera is outside sphere
    return hitPos + sign(dot(rayDirection, N)) * N * hitBias;
}

vec3 computeHitLighting(Intersection intersection, vec3 V, out float outReflectionThroughput){
	
    float lightIntensityDiffuse  = 0;
    float lightIntensitySpecular = 0;

    for (int i = 0; i < lightCount; i++) {
        
        vec3   L = normalize(inLights[i].position - intersection.pos);
        float  d = distance(inLights[i].position, intersection.pos);
		
		Ray shadowRay;
		shadowRay.origin 	= biasHitPosition(intersection.pos, L, intersection.N);
		shadowRay.direction = L;
        
        Intersection shadowIntersection = sceneIntersect(shadowRay);
        
        bool isShadowed = false;
        if(shadowIntersection.hit)
            isShadowed = distance(shadowIntersection.pos, shadowRay.origin) < d;
		
        if(isShadowed)
            continue;        
        
        lightIntensityDiffuse  += inLights[i].intensity * max(0.f, dot(L, intersection.N));
        lightIntensitySpecular += pow(max(0.f, dot(reflect(V, intersection.N), L)), intersection.material.specular_exponent) * inLights[i].intensity;
    }

    outReflectionThroughput = intersection.material.albedo[2];
    return intersection.material.diffuse_color * lightIntensityDiffuse * intersection.material.albedo[0] + lightIntensitySpecular * intersection.material.albedo[1];
}

vec3 castRay(Ray ray, int max_depth) {
    
    vec3 skyColor = vec3(0.2, 0.7, 0.8);
    
    float   reflectionThroughput    = 1;
    vec3    color                   = vec3(0);
    
    for(int i = 0; i < max_depth; i++){

        Intersection intersection = sceneIntersect(ray);
        
        vec3 hitColor;
        float hitReflectionThroughput;
        
        if(intersection.hit){
            hitColor = computeHitLighting(intersection, ray.direction, hitReflectionThroughput);
        }
        else{
            hitColor = skyColor;
        }
        
        color                   += hitColor * reflectionThroughput;
        reflectionThroughput    *= hitReflectionThroughput;
        
        if(!intersection.hit)
            break;

        ray.direction   = normalize(reflect(ray.direction, intersection.N));
        ray.origin		= biasHitPosition(intersection.pos, ray.direction, intersection.N);
    }

    return color;
}

vec3 computeCameraRay(ivec2 coord){

    ivec2 outImageRes   = imageSize(outImage);
    float fovDegree     = 45;
    float fov           = fovDegree * pi / 180;
    
    vec2 uv     = (coord + 0.5) / vec2(outImageRes);
    vec2 ndc    = 2 * uv - 1;
    
    float tanFovHalf    = tan(fov / 2.f);
    float aspectRatio   = outImageRes.x / float(outImageRes.y);
    float x             =  ndc.x * tanFovHalf * aspectRatio;
    float y             = -ndc.y * tanFovHalf;
    
    // view direction goes through pixel on image plane with z=1
    vec3 directionViewSpace     = normalize(vec3(x, y, 1));
    vec3 directionWorldSpace    = mat3(viewToWorld) * directionViewSpace;
    return directionWorldSpace;
}


void main(){
    ivec2 coord     = ivec2(gl_GlobalInvocationID.xy);
    int max_depth   = 4;
	Ray cameraRay;
    cameraRay.direction = computeCameraRay(coord);
    cameraRay.origin  	= viewToWorld[3].xyz;
    vec3 color      = castRay(cameraRay, max_depth);
    
    imageStore(outImage, coord, vec4(color, 0.f));
}